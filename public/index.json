[{"categories":null,"content":" Time2025.2.21 8.30 PM ","date":"2025-02-21","objectID":"/posts/one_netty_oom/:1:0","series":null,"tags":null,"title":"Documenting an Out-of-Memory (OOM) Error","uri":"/posts/one_netty_oom/#time"},{"categories":null,"content":" BackgroundIn the project, MQTT is used for IoT device communication, and Hook is utilized on top of MQTT for ACL and message enhancement. During a load test in the test environment, the Hook service encountered an OOM (Out Of Memory) situation. ","date":"2025-02-21","objectID":"/posts/one_netty_oom/:2:0","series":null,"tags":null,"title":"Documenting an Out-of-Memory (OOM) Error","uri":"/posts/one_netty_oom/#background"},{"categories":null,"content":" Problem:The MQTT monitoring platform is experiencing widespread hook errors. ","date":"2025-02-21","objectID":"/posts/one_netty_oom/:3:0","series":null,"tags":null,"title":"Documenting an Out-of-Memory (OOM) Error","uri":"/posts/one_netty_oom/#problem"},{"categories":null,"content":" Log 10:30:09,812 |-INFO in c.q.l.core.rolling.helper.TimeBasedArchiveRemover - Removed 100 MB of files Exception in thread \"exhook-134244\" java.lang.OutOfMemoryError: Cannot reserve 2097152 bytes of direct buffer memory (allocated: 2146302585, limit: 2147483648) at java.base/java.nio.Bits.reserveMemory(Bits.java:178) at java.base/java.nio.DirectByteBuffer.\u003cinit\u003e(DirectByteBuffer.java:121) at java","date":"2025-02-21","objectID":"/posts/one_netty_oom/:3:1","series":null,"tags":null,"title":"Documenting an Out-of-Memory (OOM) Error","uri":"/posts/one_netty_oom/#log"},{"categories":null,"content":" codeprivate void start() throws IOException { ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(corePoolSize, maxPoolSize, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003c\u003e(100), new CustomizableThreadFactory(\"exhook-\")); server = NettyServerBuilder.forPort(port) .addService(hookProvider) .executor(threadPoolExecutor) .build() .start(); log.info(\"EMQX gRPC Server started, listenin","date":"2025-02-21","objectID":"/posts/one_netty_oom/:3:2","series":null,"tags":null,"title":"Documenting an Out-of-Memory (OOM) Error","uri":"/posts/one_netty_oom/#code"},{"categories":null,"content":" ExplanationI used Netty to bind and listen on a port for handling gRPC services, which serves as the MQTT hook. But just like the aforementioned error, the callback onMessagePublish threw the above error. ","date":"2025-02-21","objectID":"/posts/one_netty_oom/:3:3","series":null,"tags":null,"title":"Documenting an Out-of-Memory (OOM) Error","uri":"/posts/one_netty_oom/#explanation"},{"categories":null,"content":" Problem Investigation The startup parameters do not include the configuration of -XX:MaxDirectMemorySize.. Therefore, the actual size of MaxDirectMemorySize is equal to the value of -Xmx, which is 2GB as shown in the logs. Check the GC (Garbage Collection) situation.Determine if excessive GC pressure led to off-heap memory overflow. add -Dio.netty.leakDetectionLevel=PARANOID/ADVANCED/SIMPLE/DISAB","date":"2025-02-21","objectID":"/posts/one_netty_oom/:4:0","series":null,"tags":null,"title":"Documenting an Out-of-Memory (OOM) Error","uri":"/posts/one_netty_oom/#problem-investigation"},{"categories":null,"content":" Method 1","date":"2024-06-26","objectID":"/posts/grpc/:0:0","series":null,"tags":null,"title":"GRPC mac istall protoc and generate Java code","uri":"/posts/grpc/#method-1"},{"categories":null,"content":" 1. install protobufbrew install protobuf ","date":"2024-06-26","objectID":"/posts/grpc/:1:0","series":null,"tags":null,"title":"GRPC mac istall protoc and generate Java code","uri":"/posts/grpc/#1-install-protobuf"},{"categories":null,"content":" 2. generate code with proto fileprotoc --java_out=./ helloworld.proto ","date":"2024-06-26","objectID":"/posts/grpc/:2:0","series":null,"tags":null,"title":"GRPC mac istall protoc and generate Java code","uri":"/posts/grpc/#2-generate-code-with-proto-file"},{"categories":null,"content":" 3. install protoc-gen-grpc-javainstall protoc-gen-grpc-java from meven: https://repo.maven.apache.org/maven2/io/grpc/protoc-gen-grpc-java/ download your version: like: protoc-gen-grpc-java-1.64.0-osx-aarch_64.exe ","date":"2024-06-26","objectID":"/posts/grpc/:3:0","series":null,"tags":null,"title":"GRPC mac istall protoc and generate Java code","uri":"/posts/grpc/#3-install-protoc-gen-grpc-java"},{"categories":null,"content":" 4. chmodneed to set executable permissions chmod +x protoc-gen-grpc-java-1.64.0-osx-aarch_64.exe ","date":"2024-06-26","objectID":"/posts/grpc/:4:0","series":null,"tags":null,"title":"GRPC mac istall protoc and generate Java code","uri":"/posts/grpc/#4-chmod"},{"categories":null,"content":" 5. generate grpc service class protoc --plugin=protoc-gen-grpc-java=/your-path/protoc-gen-grpc-java-1.64.0-osx-aarch_64.exe --grpc-java_out=./ helloworld.proto ","date":"2024-06-26","objectID":"/posts/grpc/:5:0","series":null,"tags":null,"title":"GRPC mac istall protoc and generate Java code","uri":"/posts/grpc/#5-generate-grpc-service-class"},{"categories":null,"content":" Method 2 ✅","date":"2024-06-26","objectID":"/posts/grpc/:0:0","series":null,"tags":null,"title":"GRPC mac istall protoc and generate Java code","uri":"/posts/grpc/#method-2---"},{"categories":null,"content":" 1. add dependencies\u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eio.grpc\u003c/groupId\u003e \u003cartifactId\u003egrpc-netty-shaded\u003c/artifactId\u003e \u003cversion\u003e1.64.0\u003c/version\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.grpc\u003c/groupId\u003e \u003cartifactId\u003egrpc-protobuf\u003c/artifactId\u003e \u003cversion\u003e1.64.0\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.grpc\u003c/groupId\u003e \u003cartifactId\u003egrpc-stub\u003c/artifactId\u003e \u003cversion\u003e1.64.0\u003c/version\u003e","date":"2024-06-26","objectID":"/posts/grpc/:1:0","series":null,"tags":null,"title":"GRPC mac istall protoc and generate Java code","uri":"/posts/grpc/#1-add-dependencies"},{"categories":null,"content":" 2. add plugin\u003cplugin\u003e \u003cgroupId\u003eorg.xolstice.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003eprotobuf-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e0.6.1\u003c/version\u003e \u003cconfiguration\u003e \u003cprotocArtifact\u003ecom.google.protobuf:protoc:3.25.1:exe:${os.detected.classifier}\u003c/protocArtifact\u003e \u003cpluginId\u003egrpc-java\u003c/pluginId\u003e \u003cpluginArtifact\u003eio.grpc:protoc-gen-grpc-java:1.64.0:exe:${os.detected.classifier}\u003c/pluginArtifact\u003e \u003c!-- \u003coutputDire","date":"2024-06-26","objectID":"/posts/grpc/:2:0","series":null,"tags":null,"title":"GRPC mac istall protoc and generate Java code","uri":"/posts/grpc/#2-add-plugin"},{"categories":null,"content":" 3. generate code with proto file1.run protobuf compile 2.run protobuf compile-custom ","date":"2024-06-26","objectID":"/posts/grpc/:3:0","series":null,"tags":null,"title":"GRPC mac istall protoc and generate Java code","uri":"/posts/grpc/#3-generate-code-with-proto-file"},{"categories":null,"content":" Name","date":"2023-10-27","objectID":"/about/:1:0","series":null,"tags":null,"title":"","uri":"/about/#name"},{"categories":null,"content":" 各种软件","date":"2023-10-27","objectID":"/about/:2:0","series":null,"tags":null,"title":"","uri":"/about/#各种软件"},{"categories":null,"content":" navicathttps://gitlab.com/ajiajishu/navicat-keygen-16V https://www.123pan.com/s/YheEjv-gopXv.html xXbg ","date":"2023-10-27","objectID":"/about/:2:1","series":null,"tags":null,"title":"","uri":"/about/#navicat"},{"categories":null,"content":" 什么是Service Mesh 现代应用程序通常被架构为分布式微服务集合，每个微服务集合执行一些离散的业务功能。服务网格是一个专用的基础设施层，您可以将其添加到您的应用程序中。它允许您透明地添加可观察性、流量管理和安全性等功能，而无需将它们添加到您自己的代码中。术语“服务网格”描述了用于实现此模式的软件类型，以及使用该软件时创建的安全或网络域。 随着分布式服务的部署（例如在基于 Kubernetes 的系统中）的规模和复杂性的增长，它可能会变得更难以理解和管理。其需求可包括发现、负载平衡、故障恢复、指标和监控。服务网格通常还可以解决更复杂的操作需求，例如 A/B 测试、金丝雀部署、速率限制、访问控制、加密和端到端身份验证。 服务到服务的通信使分布式应用程序成为可能。随着服务数量的增长，在应用程序集群内部和之间路由这种通信变得越来越复杂。 ","date":"2023-10-27","objectID":"/posts/service_mesh/:1:0","series":null,"tags":null,"title":"service mesh","uri":"/posts/service_mesh/#什么是service-mesh"},{"categories":null,"content":" 1. JVM现状","date":"2023-10-27","objectID":"/posts/understanding_jvm/:1:0","series":null,"tags":null,"title":"深入理解Java虚拟机","uri":"/posts/understanding_jvm/#1-jvm现状"},{"categories":null,"content":" 当前环境下Java的劣势在微服务架构的视角下，有了高可用的服务集群，也就无需追求单个服务7*24小时运行，反而因为Java的启动时间相对较长，需要预热才能达到最高性能等特点就显得有悖于这样的应用场景。 比起服务，一个函数的规模通常会更小，执行时间更短，当前最热门的无服务运行环境AWS Lambda 所允许的最长运行时间仅有15分钟。 ","date":"2023-10-27","objectID":"/posts/understanding_jvm/:1:1","series":null,"tags":null,"title":"深入理解Java虚拟机","uri":"/posts/understanding_jvm/#当前环境下java的劣势"},{"categories":null,"content":" Java的提前编译**提前编译(Ahead of Time Compilation ATO)**是相对于即时编译的概念。 提前编译能带来的最大好处是Java虚拟机加载这些已经编译成二进制库之后就能够直接调用，而无需等待即时编译器在运行时将其编译成二进制机器码。理论上，提前编译可以减少即时编译带来的预热时间。 但是提前编译的坏处也很明显，它破坏了Java “一次编写，到处运行”的承诺，必须为不同的硬件、操作系统编译对应的发行包，必须要求加载的代码在编译期就是全部已知的，而不能在运行期才确定，否则就只能舍弃掉已经提前编译好的版本 ","date":"2023-10-27","objectID":"/posts/understanding_jvm/:1:2","series":null,"tags":null,"title":"深入理解Java虚拟机","uri":"/posts/understanding_jvm/#java的提前编译"},{"categories":null,"content":" Substrate VMSubstrate VM 是在Graal VM 0.20版本里出现的一个极小型的运行时环境，包括了独立的议程处理、同步调度、线程管理、内存管理(垃圾回收)和JNI访问等组件，目标是替代HotSpot来支持提前编译后的程序执行。它还包含了一个本地镜像的构造器(Native Image Generator), 用于为用户程序建立基于Substrate VM的本地运行环境 构造器采用**指针分析(Points-To Analysis)**技术，从用户提供的程序入口出发，搜索所有可达的代码，在搜索的同时，它还执行初始化代码，并在最终生成可执行文件时，将已初始化的堆保存至一个堆快照中。在执行时无需重复进行Java虚拟机的初始化过程。 ","date":"2023-10-27","objectID":"/posts/understanding_jvm/:1:3","series":null,"tags":null,"title":"深入理解Java虚拟机","uri":"/posts/understanding_jvm/#substrate-vm"},{"categories":null,"content":" 2. 运行时数据区域 ","date":"2023-10-27","objectID":"/posts/understanding_jvm/:2:0","series":null,"tags":null,"title":"深入理解Java虚拟机","uri":"/posts/understanding_jvm/#2-运行时数据区域"},{"categories":null,"content":" 程序计数器(Program Counter Pegister)线程私有 程序计数器 是流程控制的指示器，各条线程之间计数器互不影响，独立存储(线程私有) 是唯一一个没有规定任何OutOfMemoryError(OOM)情况的区域 ","date":"2023-10-27","objectID":"/posts/understanding_jvm/:2:1","series":null,"tags":null,"title":"深入理解Java虚拟机","uri":"/posts/understanding_jvm/#程序计数器program-counter-pegister"},{"categories":null,"content":" Java虚拟机栈(Java Virtual Machine Stack)线程私有 Java虚拟机栈描述的是Java方法执行的线程内存模型，生命周期与线程相同 每个方法被调用直至执行完毕的过程，就对应着一个栈帧(Stack Frame)在虚拟机栈中从入栈道出栈的过程。 每个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小 如果线程请求的栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError 如果Java虚拟机栈容量可以动态扩展(HotSpot栈容量不可以动态扩展)，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError ","date":"2023-10-27","objectID":"/posts/understanding_jvm/:2:2","series":null,"tags":null,"title":"深入理解Java虚拟机","uri":"/posts/understanding_jvm/#java虚拟机栈java-virtual-machine-stack"},{"categories":null,"content":" 本地方法栈(Native Method Stack)线程私有 本地方法栈与Java虚拟机栈所发挥的作用非常相似，区别只是虚拟机栈为执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的本地方法(Native)方法服务 与虚拟机栈一样会抛出StackOverflowError 和 OutOfMemoryError ","date":"2023-10-27","objectID":"/posts/understanding_jvm/:2:3","series":null,"tags":null,"title":"深入理解Java虚拟机","uri":"/posts/understanding_jvm/#本地方法栈native-method-stack"},{"categories":null,"content":" Java堆(Java Heap)线程共享 Java堆唯一目的就是存放对象实例(所有对象实例以及数组都应当在堆上分配)，但是由于逃逸分析技术日渐强大，栈上分配、标量替换优化等手段已导致一些变化。 Java堆是垃圾收集器管理的内存区域，因此也被叫做GC堆(Garbage Collected Heap)。 Java堆可以处于物理上不连续的内存空间中，但在逻辑上应该被视为连续的 Java堆可以扩展，通过参数(-Xmx 和 -Xms设定) 如果堆中没有内存完成实例分配，并且堆也无法扩展时，将抛出 OutOfMemoryError ","date":"2023-10-27","objectID":"/posts/understanding_jvm/:2:4","series":null,"tags":null,"title":"深入理解Java虚拟机","uri":"/posts/understanding_jvm/#java堆java-heap"},{"categories":null,"content":" 方法区(Method Area)线程共享 方法区(也叫非堆 Non-Heap)方法取用于存放已被虚拟机加载的类型信息、常量，静态变量、即时编译器编译后的代码缓存等数据。 如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError ","date":"2023-10-27","objectID":"/posts/understanding_jvm/:2:5","series":null,"tags":null,"title":"深入理解Java虚拟机","uri":"/posts/understanding_jvm/#方法区method-area"},{"categories":null,"content":" 运行时常量池(Runtime Constant Pool)运行时常量池是方法区的一部分，常量池表(Constant Pool Table)用于存放编译期生成的各种字面量与符号引用 运行期间也可以将新的常量放入池中(String的intern()方法) 当常量池无法再申请到内存时会抛出 OutOfMemoryError ","date":"2023-10-27","objectID":"/posts/understanding_jvm/:2:6","series":null,"tags":null,"title":"深入理解Java虚拟机","uri":"/posts/understanding_jvm/#运行时常量池runtime-constant-pool"},{"categories":null,"content":" 直接内存(Direct Memory)直接内存 并不是虚拟机运行时数据区的一部分，但是被频繁使用，也可能抛出OutOfMemoryError 典型 NIO(New Input/Output) 可以使用Native函数库直接分配堆外内存，然后通过Java堆里的DirectByteBuffer对象作为这块内存的引用进行操作，更高效(避免了Java堆与Native堆中来回复制数据) 若内存区域总和大于物理内存限制，会出现OutOfMemoryError ","date":"2023-10-27","objectID":"/posts/understanding_jvm/:2:7","series":null,"tags":null,"title":"深入理解Java虚拟机","uri":"/posts/understanding_jvm/#直接内存direct-memory"},{"categories":null,"content":" 3. GC","date":"2023-10-27","objectID":"/posts/understanding_jvm/:3:0","series":null,"tags":null,"title":"深入理解Java虚拟机","uri":"/posts/understanding_jvm/#3-gc"},{"categories":null,"content":" 判断对象是否存活 引用计数法(Reference Counting)每有一个地方引用对象时，计数器+1，引用失效时，计数器-1，计数器为0的对象就是不可能再被使用的 好处：原理简单，效率高 缺陷：单纯的引用计数就很难解决对象循环引用的问题 可达性分析算法(Reachability Analysis)从GC Root 到对象不可达时，表明此对象不可能再被使用 固定可作为GC Roots 的对象包括以下几种： 虚拟机栈中引用的对象 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI(即Native方法)引用的对象 Java虚拟机内部的引用 如系统类加载器，基本数据类型对应的class对象等 所有被同步锁(synchronized关键字)持有的对象 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。 ","date":"2023-10-27","objectID":"/posts/understanding_jvm/:3:1","series":null,"tags":null,"title":"深入理解Java虚拟机","uri":"/posts/understanding_jvm/#判断对象是否存活"},{"categories":null,"content":" 判断对象是否存活 引用计数法(Reference Counting)每有一个地方引用对象时，计数器+1，引用失效时，计数器-1，计数器为0的对象就是不可能再被使用的 好处：原理简单，效率高 缺陷：单纯的引用计数就很难解决对象循环引用的问题 可达性分析算法(Reachability Analysis)从GC Root 到对象不可达时，表明此对象不可能再被使用 固定可作为GC Roots 的对象包括以下几种： 虚拟机栈中引用的对象 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI(即Native方法)引用的对象 Java虚拟机内部的引用 如系统类加载器，基本数据类型对应的class对象等 所有被同步锁(synchronized关键字)持有的对象 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。 ","date":"2023-10-27","objectID":"/posts/understanding_jvm/:3:1","series":null,"tags":null,"title":"深入理解Java虚拟机","uri":"/posts/understanding_jvm/#引用计数法reference-counting"},{"categories":null,"content":" 判断对象是否存活 引用计数法(Reference Counting)每有一个地方引用对象时，计数器+1，引用失效时，计数器-1，计数器为0的对象就是不可能再被使用的 好处：原理简单，效率高 缺陷：单纯的引用计数就很难解决对象循环引用的问题 可达性分析算法(Reachability Analysis)从GC Root 到对象不可达时，表明此对象不可能再被使用 固定可作为GC Roots 的对象包括以下几种： 虚拟机栈中引用的对象 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI(即Native方法)引用的对象 Java虚拟机内部的引用 如系统类加载器，基本数据类型对应的class对象等 所有被同步锁(synchronized关键字)持有的对象 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。 ","date":"2023-10-27","objectID":"/posts/understanding_jvm/:3:1","series":null,"tags":null,"title":"深入理解Java虚拟机","uri":"/posts/understanding_jvm/#可达性分析算法reachability-analysis"},{"categories":null,"content":" 引用类型 强引用(Strongly Reference)。 即普遍存在的引用赋值，无论任何情况下，只要强引用关系存在，垃圾收集器就永远不会会收掉被引用的对象。 软引用(Soft Reference)。 将要发生内存溢出异常前，会把这些对象列进回收范围 若引用(Weak Reference)。 只能存活到下次垃圾回收发生 虚引用(Phantom Reference)。 无法通过虚引用来获取一个对象实例，为一个对象设置虚引用的唯一目的只是为了能在这个对象被收集器回收时收到一个通知。 ","date":"2023-10-27","objectID":"/posts/understanding_jvm/:3:2","series":null,"tags":null,"title":"深入理解Java虚拟机","uri":"/posts/understanding_jvm/#引用类型"}]